# Rotated Sorted Array

An array is sorted in ascending or descending order and then rotated at some unknown pivots. For convenience, we only talk about cases where the array was orinally sorted in ascending order. Below is an example of all the rotated sorted arrays generated by the same array.
![image](https://github.com/idanhuang/idanhuang.github.io/blob/master/image/roated_sorted_array_1.png)


In math, an inflection point is a point on a curve at which the sign of curvature changes. In a rotated sorted array, we call a point inflection point (red line shown as below) such that all the elements in its left interval are greater than the first element, and all the elements in its right interval are less than the first element.
![image](https://github.com/idanhuang/idanhuang.github.io/blob/master/image/roated_sorted_array_2.png)


## [LC 33 Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/submissions/)
  
Same as the regular binary search, the idea of solving this problem is keep narrowing down the search range until the target is found. However, we can't eliminate half of the elements every time by just comparing target and nums[mid] since the entire array is neither in ascending order nor in descending order after the rotation. But we can still find a monotone interval and use it to narrow down the search range. 
   
   - If nums[mid] >= nums[left] then [left, mid] is a monotone interval in which all the elements are sorted in ascending order. In this case, if target is within range [left, mid) then we narrow down search range to [left,mid-1], otherwise we narrow down search range to [mid+1, right]. 
   - If nums[mid] < nums[left] then [mid, right] is a montone interval in which all the elements are sorted in ascending order. In this case, if target is within range (mid,right] then we narrow down search range to [mid+1,right], otherwise we narrow down search range to [left,mid-1].

   <img src="https://github.com/idanhuang/idanhuang.github.io/blob/master/image/rotated_sorted_array_4.png" data-canonical-src="https://github.com/idanhuang/idanhuang.github.io/blob/master/image/rotated_sorted_array_4.png" width="550" height="250" />
  
```C#
        public class Solution {
            public int Search(int[] nums, int target) {

                if(nums == null || nums.Length == 0)
                    return -1;

                int left = 0, right = nums.Length - 1;

                while(left <= right)
                {
                    int mid = left + (right - left) / 2;

                    if(target == nums[mid])
                    {
                        return mid;
                    }
                    else if(nums[mid] >= nums[left])
                    {
                        if(target >= nums[left] && target < nums[mid])
                            right = mid - 1;
                        else
                            left = mid + 1;
                    }
                    else
                    {
                        if(target > nums[mid] && target <= nums[right])
                            left = mid + 1;
                        else
                            right = mid - 1;
                    }
                }

                return -1;
            }
        }
```

## [LC 81 Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii)

The main difference between LC 81 and LC33 is that LC 81 may have duplicates in the rotated sorted array while LC 33 doesn't. But we still can find the monotone interval and use it to narrow down the search range by comparing nums[mid] and nums[left].

   - if nums[mid] >= nums[left], then [left,mid] is a monotone interval in which all the elements are sorted in ascending order.
   - if nums[mid] < nums[left], then [mid, right] is a montone interval in which all the elements are sorted in ascending order.

  ![image](https://github.com/idanhuang/idanhuang.github.io/blob/master/image/rotated_sorted_array_5.png)
    
Since the array may contain duplicates, we may have a case that even nums[mid] >= nums[left], range [left,mid] is not a montone interval. If this is the case, then it's guranteed that nums[right] == nums[mid] as well (if not, the array won't be a rotated sorted array). In this case, we can narrow down the search range by moving left pointer rightward by 1 and moving right ponter leftward by one, because:

  - if target == nums[mid], then target will be found later and we can narrow down the search range.
  - if target != nums[mid], then the operation will narrow down the search range.
    
   <img src="https://github.com/idanhuang/idanhuang.github.io/blob/master/image/rotated_sorted_array_6.png" data-canonical src="https://github.com/idanhuang/idanhuang.github.io/blob/master/image/rotated_sorted_array_6.png" width="360" height="200" />

```C#
    public class Solution {
        public bool Search(int[] nums, int target) {

            if(nums == null || nums.Length == 0)
                return false;

            int left = 0, right = nums.Length - 1;

            while(left <= right)
            {
                int mid = left + (right - left) / 2;

                if(target == nums[mid])
                    return true;
                else if(nums[mid] == nums[left] && nums[mid] == nums[right])
                {
                    left++;
                    right--;
                }
                else if(nums[mid] >= nums[left])
                {
                    if(target >= nums[left] && target < nums[mid])
                        right = mid - 1;
                    else
                        left = mid + 1;
                }
                else
                {
                    if(target > nums[mid] && target <= nums[right])
                        left = mid + 1;
                    else
                        right = mid - 1;
                }
            }

            return false;
        }
    }
```

- LC 153 Find Minimum in Rotated Sorted Array
- LC 154 Find Minimum in Rotated Sorted Array II
